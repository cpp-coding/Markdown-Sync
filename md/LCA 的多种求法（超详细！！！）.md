> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [www.360doc.com](http://www.360doc.com/content/19/0813/22/13328254_854705322.shtml)

> LCA 的多种求法（超详细！！！）

倍增求 LCA
-------

### (1) 树上倍增法 预处理

### 设 f[x,k] 表示 x 的 2^k 辈祖先, 即从 x 向根节点走 2^k 步到达的节点。特别地, 若该节点不存在, 则令 f[x,k]=0。f[x,0] 就是 x 的父节点。可以得出 f[x][k]=f[f[x][k-1]][k-1]。

### 我们可以对树进行遍历, 由此得到 f[x,0]，再计算 f 数组所有值。

### 以上部分是预处理, 时间复杂度为 O(nlogn)。之后可以多次对不同的 x,y 计算 LCA, 每次询问的时间复杂度为 O(logn)。

```
【代码实现】 预处理
void dfs(int u,int father)  
{
    Dep[u]=Dep[father] 1;    
    for(int i=0;i<=19;i  )    
    f[u][i 1]=f[f[u][i]][i];  
    for(int e=first[u],v; v=go[e],e; e=next[e])    
    {        
        if(v==father) continue;    
        f[v][0]=u;                       //v向上跳2^0=1就是u    
        dfs(v,u);    
    }    
} 
```

### （2）基于 f 数组计算 LCA(x,y)

### 分为以下几步:

### 1. 设 dep[x] 表示 x 的深度。不妨设 dep[x]≥dep[y](否则可交换 x,y)。

### 2. 用二进制拆分思想, 把 x 向上调整到与 y 同一深度。具体来说, 就是依次尝试从 x 向上走 k= 2logn,…,21,20 步, 若到达的节点比 y 深, 则令 x=f[x,k]。

### 3. 若此时 x=y, 说明已经找到了 LCA,LCA 就等于 y。

### 4. 若此时 x≠y，依次尝试把 x,y 同时向上走 k= 2logn,…,21,20 步, 若 f[x,k]≠f[y,k](即仍未相会), 则令 x=f[x,k],y=f[y,k]。

### 5. 此时 x,y 必定只差一步就相会了, 它们的父节点 f[x,0] 就是 LCA。

```
【代码实现】 查询x,y的LCA
int LCA(int x,int y)                   
{    
    if(Dep[x]<Dep[y]) swap(x,y);  //让x深度较大   
    for(int i=20;i>=0;i--)        //先将x,y跳到一个深度，一定要倒着for    
      if(Dep[f[x][i]]>=Dep[y]) x=f[x][i];  //先跳到同一层    
    if(x==y) return x;           //如果相等直接返回
    for(int i=20;i>=0;i--)       //此时x,y已跳到同一层   
        if(f[x][i]!=f[y][i])     //如果f[x][i]和f[y][i]不同才跳  
          x=f[x][i],y=f[y][i];  
    return f[x][0];       //x,y是深度最浅且不同的点，即lca的子结点 
} 
```

树链剖分求 LCA
---------

### 将静态树上的点按某种方式组织起来，剖分成为若干条链，形成若干个序列，则操作路径就会被拆分为几条链，也就是若干个完整序列 

### 轻重边剖分： 我们将树中的边分成重边和轻边。如下图，加粗的边是重边，其余是轻边。 我们可以以任意点为根，然后记 size[u]为以 u 为根的子树的结点个数，令 为 v 所有儿子中 size 值最大的一个儿子，则 (u,v) 为重边, v 称为 u 的重儿子。 到其余儿子的边为轻边。

### ![](http://image109.360doc.com/DownloadImg/2019/08/1322/168413887_1_20190813105646660.png)

### 轻重边剖分的过程可以使用两次 dfs 来实现。

### 剖分过程中要计算如下 5 个值：

### f[x]:x 在树中的父亲

### size[x]:x 的子树结点数 (子树大小)

### dep[x]:x 在树中的深度

### son[x]:x 的重儿子，即为重边

### top[x]:x 所在重路径的顶部结点 (深度最小)

### ![](http://image109.360doc.com/DownloadImg/2019/08/1322/168413887_2_2019081310564797.png)

### 第一遍 dfs 计算前 4 个值， 第二遍 dfs 计算后 1 个值。

### 查询 LCA:

### 1、找到 x、y 所在的链头

### 2、如果两个链头不相等，则选择链头深度大的往上跳

### 3、最后两个链头相等，说明在同一条重路径上，深度浅的就是 LCA

### ![](http://image109.360doc.com/DownloadImg/2019/08/1322/168413887_3_20190813105647410.png)

### 看到这里勤奋好学的你一定已经摩拳擦掌、跃跃欲试了吧

### 那么我们来做一道简单的模板题

### 【例 1】点的距离

### 【题目描述】

### 给定一棵 n 个点的树，Q 个询问，每次询问点 x 到点 y 两点之间的距离。

### 【输入】

### 第一行一个正整数 n，表示这棵树有 n 个节点； 接下来 n−1 行，每行两个整数 x,y 表示 x,y 之间有一条连边； 然后一个整数 Q，表示有 Q 个询问； 接下来 Q 行每行两个整数 x,y 表示询问 x 到 y 的距离。

### 【输出】

### 输出 Q 行，每行表示每个询问的答案。

### 【输入样例】

### 6 1 2 1 3 2 4 2 5 3 6 2 2 6 5 6

### 【输出样例】

### 3 4

### ---（QAQ 格式的问题我真的搞不 nai）

### 解法一：倍增

### ![](http://image109.360doc.com/DownloadImg/2019/08/1322/168413887_4_20190813105647832.png)

![](http://image109.360doc.com/DownloadImg/2019/08/1322/168413887_5_20190813105648254.png)

### 解法二：树链剖分

![](http://image109.360doc.com/DownloadImg/2019/08/1322/168413887_6_20190813105648597.png)

![](http://image109.360doc.com/DownloadImg/2019/08/1322/168413887_7_20190813105649144.png)

### 如果还想进一步了解运用 LCA，亲亲，这边建议您可以去 AC 这道题题哦~

### 这是一个[传送门](https://www.cnblogs.com/ljy-endl/p/11349080.html)...（才不是没有灵魂的可爱传送门呢 QWQ）

### 蟹蟹资瓷，请顺手点个 “推荐” 吧~ mua(づ￣3￣)づ╭❤～

来源：