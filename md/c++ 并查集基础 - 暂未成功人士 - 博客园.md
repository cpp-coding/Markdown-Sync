> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [www.cnblogs.com](https://www.cnblogs.com/lihanyu116/p/14985126.html)

> 前言 并查集是一种多叉树，用于处理不相交的集合的合并与查询问题（判断）。 通俗理解：在日常生活中，我们会因为某个人是自己的朋友，哪怕是朋友的朋友也是有朋友，会给予通融、 偏袒。而并查集的基本概念，就是

**前言**

并查集是一种多叉树，用于处理不相交的集合的合并与查询问题（判断）。

通俗理解：在日常生活中，我们会因为某个人是自己的朋友，哪怕是朋友的朋友也是有朋友，会给予通融、 偏袒。而并查集的基本概念，就是判断某两个集合是否是 “朋友” 关系，并让两个集合成为“朋友”

**常用操作**

初始化：每个结点单独作为一个集合

查询：求元素所在的集合的代表元素，即根结点

合并：将两个元素所在的集合，合并为一个集合

合并之前，应先判断两个元素是否属于同一集合，用上面的 “查询” 来实现

**算法实现**

初始化: 初始的时候每个结点各自为一个集合, father[i] 表示结点 i 的父亲结点, 如果 father[i]=i, 我们认为这个结点是当前集合根结点（开始时每个节点根节点是他自己）。

```
void init() {

    for (int i = 1; i <= n; ++i) {

        father[i] = i;

    }

}
```

查找: 查找结点所在集合的根结点, 结点 x 的根结点必然也是其父亲结点的根结点（像是有递归的样子）。

```
int get(int x) {

    if (father[x] == x) { // x 结点就是根结点

        return x; 

    }

    return get(father[x]); // 如果该节点不是根节点，继续寻找父结点的根结点

}
```

合并: 将两个元素所在的集合合并在一起, 通常来说, 合并之前先判断两个元素是否属于同一集合。

```
void hebing(int x, int y) {

    x = find(x);

    y = find(y);

    if (x != y) { // 不在同一个集合

        father[y] = x;//将根节点合并

    }

}
```

上面三个操作是并查集常用的操作

前面的并查集的复杂度实际上在有些极端情况会很慢。比如树的结构正好是一条链，那么最坏情况下，每次查询的复杂度达到了 O(n) 。这并不是我们期望的结果。**路径压缩的思想是，我们只关心每个结点的父结点，而并不太关心树的真正的结构（递归查找相当浪费时间）如下：**

**![](https://img2020.cnblogs.com/blog/2448947/202107/2448947-20210708105150974-1960523435.png)**

 当想去访问 6 的根节点时，要访问 5 的根节点，想去访问 5 的根节点，又要去访问 4 的根节点.......... 以此类推，此时并查集退化为线性。

**这样我们在一次查询的时候，可以把查询路径上的所有结点的 father[i] 都赋值成为根结点。只需要在我们之前的查询函数上面进行很小的改动**

```
int findf(int k)
{     if(f[k] == k) 
        return k;     
        return f[k] = findf(f[k]); //后来更新的点的根节点直接为最开始的点，一步找到总根节点。
}
```

**初步学习理解，如有不足请指出，谢谢**